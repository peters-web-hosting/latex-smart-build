name: 'Smart Build for LaTeX'
description: 'Automatically compile LaTeX documents with smart dependency tracking, only rebuilding affected documents when files change'
author: 'PeterTSmith1997'

branding:
  icon: 'file-text'
  color: 'blue'

inputs:
  max-drafts:
    description: 'Maximum number of draft PDFs to keep per document'
    required: false
    default: '3'
  
  output-dir:
    description: 'Directory to store compiled PDFs'
    required: false
    default: 'drafts'
  
  compiler:
    description: 'LaTeX compiler to use (xelatex, pdflatex, lualatex)'
    required: false
    default: 'xelatex'
  
  biber:
    description: 'Run biber for bibliography processing'
    required: false
    default: 'true'
  
  commit-message:
    description: 'Commit message for PDF updates'
    required: false
    default: 'Update PDFs'

  wordcount-files:
    description: 'Comma-separated list of top-level TeX files to update wordcount for (leave empty to disable)'
    required: false
    default: ''
  
  exclude-files:
    description: 'Comma-separated list of TeX files to never recompile (e.g., archived documents, stable releases)'
    required: false
    default: ''

runs:
  using: 'composite'
  steps:
    - name: Get changed files
      id: changed
      uses: tj-actions/changed-files@v47

    - name: Find top-level TeX files
      id: toplevel
      shell: bash
      run: |
        TOPLEVEL=""
        for f in $(find . -type f -name "*.tex"); do
          if grep -q '\\documentclass' "$f"; then
            TOPLEVEL="$TOPLEVEL $f"
          fi
        done
        echo "files=$TOPLEVEL" >> $GITHUB_OUTPUT

    - name: Decide which TeX files to build
      id: buildset
      shell: bash
      run: |
        # Parse exclude list
        parse_exclude_list() {
          local exclude_list=""
          if [[ "${{ inputs.exclude-files }}" != "" ]]; then
            IFS=',' read -ra EXCLUDED <<< "${{ inputs.exclude-files }}"
            for ex in "${EXCLUDED[@]}"; do
              # Trim whitespace and normalize path
              ex=$(echo "$ex" | xargs)
              # Add .tex extension if not present
              [[ "$ex" != *.tex ]] && ex="${ex}.tex"
              # Normalize path (remove leading ./ if present)
              ex="${ex#./}"
              exclude_list="$exclude_list $ex"
            done
          fi
          echo "$exclude_list"
        }
        
        # Check if file is in exclude list
        is_excluded() {
          local file="$1"
          local exclude_list="$2"
          # Normalize the file path for comparison
          local norm_file="${file#./}"
          
          for excluded in $exclude_list; do
            # Check exact match or basename match
            if [[ "$norm_file" == "$excluded" ]] || [[ "$(basename "$norm_file")" == "$excluded" ]]; then
              return 0
            fi
          done
          return 1
        }
        
        find_dependent_mains() {
          local changed_file="$1"
          local exclude_list="$2"
          local basename=$(basename "$changed_file" .tex)
          local rel_path="${changed_file#./}"
          local rel_path_no_ext="${rel_path%.tex}"
          local mains=()

          for main in ${{ steps.toplevel.outputs.files }}; do
            # Skip if this main file is in the exclude list
            if is_excluded "$main" "$exclude_list"; then
              echo "âš ï¸ Skipping excluded file: $main" >&2
              continue
            fi
            
            if [[ "$main" == "$changed_file" ]]; then
              mains+=("$main")
              continue
            fi

            patterns=("$basename" "$rel_path_no_ext" "$rel_path")
            main_dir=$(dirname "$main")
            rel_from_main=$(realpath --relative-to="$main_dir" "$changed_file" 2>/dev/null || echo "")
            [[ -n "$rel_from_main" ]] && patterns+=("${rel_from_main%.tex}")

            for p in "${patterns[@]}"; do
              if grep -E "\\\\(include|input)\\{[^}]*${p}[^}]*\\}" "$main" >/dev/null 2>&1; then
                mains+=("$main")
                break
              fi
            done
          done

          echo "${mains[@]}" | tr ' ' '\n' | sort -u
        }

        EXCLUDE_LIST=$(parse_exclude_list)
        [[ -n "$EXCLUDE_LIST" ]] && echo "ðŸ“Œ Excluded files:$EXCLUDE_LIST"
        
        FILES=""
        CHANGED="${{ steps.changed.outputs.all_changed_files }}"

        for file in $CHANGED; do
          if [[ "$file" == *.tex ]]; then
            if grep -q '\\documentclass' "$file" 2>/dev/null; then
              # Check if this main file should be excluded
              if ! is_excluded "$file" "$EXCLUDE_LIST"; then
                [[ ! " $FILES " =~ " $file " ]] && FILES="$FILES $file"
              else
                echo "âš ï¸ Skipping excluded file: $file"
              fi
            else
              dependent_mains=$(find_dependent_mains "$file" "$EXCLUDE_LIST")
              for main in $dependent_mains; do
                [[ ! " $FILES " =~ " $main " ]] && FILES="$FILES $main"
              done
            fi
          fi
        done

        echo "files=$FILES" >> $GITHUB_OUTPUT

    - name: Determine which wordcount files need updating
      id: wordcount_check
      shell: bash
      run: |
        WC_TO_UPDATE=""
        
        if [[ "${{ inputs.wordcount-files }}" != "" ]]; then
          IFS=',' read -ra WC_FILES <<< "${{ inputs.wordcount-files }}"
          CHANGED="${{ steps.changed.outputs.all_changed_files }}"
          
          # Parse exclude list for wordcount checking
          EXCLUDE_LIST=""
          if [[ "${{ inputs.exclude-files }}" != "" ]]; then
            IFS=',' read -ra EXCLUDED <<< "${{ inputs.exclude-files }}"
            for ex in "${EXCLUDED[@]}"; do
              ex=$(echo "$ex" | xargs)
              [[ "$ex" != *.tex ]] && ex="${ex}.tex"
              EXCLUDE_LIST="$EXCLUDE_LIST ${ex#./}"
            done
          fi
          
          for wc_file in "${WC_FILES[@]}"; do
            # Trim whitespace
            wc_file=$(echo "$wc_file" | xargs)
            
            # Skip if this file is in the exclude list
            norm_wc="${wc_file#./}"
            skip=false
            for excluded in $EXCLUDE_LIST; do
              if [[ "$norm_wc" == "$excluded" ]] || [[ "$(basename "$norm_wc")" == "$excluded" ]]; then
                echo "âš ï¸ Skipping word count for excluded file: $wc_file"
                skip=true
                break
              fi
            done
            [[ "$skip" == true ]] && continue
            
            # Check if this wordcount file or any of its dependencies have changed
            if echo "$CHANGED" | grep -q "$wc_file"; then
              WC_TO_UPDATE="$WC_TO_UPDATE $wc_file"
            else
              # Check if any of the changed files are included in this wordcount file
              for changed in $CHANGED; do
                if [[ "$changed" == *.tex ]]; then
                  basename=$(basename "$changed" .tex)
                  if grep -E "\\\\(include|input)\\{[^}]*${basename}[^}]*\\}" "$wc_file" >/dev/null 2>&1; then
                    WC_TO_UPDATE="$WC_TO_UPDATE $wc_file"
                    break
                  fi
                fi
              done
            fi
          done
        fi
        
        echo "files=$WC_TO_UPDATE" >> $GITHUB_OUTPUT
        if [[ -n "$WC_TO_UPDATE" ]]; then
          echo "ðŸ“Š Word count will be updated for:$WC_TO_UPDATE"
        else
          echo "ðŸ“Š No word count updates needed"
        fi

    - name: Report if no TeX files need building
      if: steps.buildset.outputs.files == ''
      shell: bash
      run: echo "âœ“ No TeX files changed â†’ skipping build."

    - name: Install LaTeX
      if: steps.buildset.outputs.files != ''
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install -y texlive-xetex texlive-latex-extra texlive-extra-utils biber latexmk

    - name: Compile selected TeX files
      if: steps.buildset.outputs.files != ''
      shell: bash
      run: |
        mkdir -p ${{ inputs.output-dir }}
        TIMESTAMP=$(date +"%Y-%m-%d_%H-%M")
        COMPILER="${{ inputs.compiler }}"
        USE_BIBER="${{ inputs.biber }}"
        MAX_DRAFTS="${{ inputs.max-drafts }}"

        for texfile in ${{ steps.buildset.outputs.files }}; do
          BASENAME=$(basename "$texfile" .tex)
          DIRNAME=$(dirname "$texfile")
          cd "$DIRNAME"

          echo "ðŸ“„ Compiling $texfile with $COMPILER..."
          $COMPILER "$BASENAME.tex"

          if [[ "$USE_BIBER" == "true" ]]; then
            echo "ðŸ“š Running biber..."
            biber "$BASENAME" || true
          fi

          $COMPILER "$BASENAME.tex"
          $COMPILER "$BASENAME.tex"

          cp "$BASENAME.pdf" "$GITHUB_WORKSPACE/${{ inputs.output-dir }}/${BASENAME}_$TIMESTAMP.pdf"

          cd "$GITHUB_WORKSPACE/${{ inputs.output-dir }}"
          ls -1 "${BASENAME}_"*.pdf 2>/dev/null | sort -r | tail -n +$((MAX_DRAFTS + 1)) | xargs -r rm -v
          cd "$GITHUB_WORKSPACE"
        done

    - name: Update word counts
      if: steps.wordcount_check.outputs.files != ''
      shell: bash
      run: |
        WC_FILES="${{ steps.wordcount_check.outputs.files }}"
        
        for wc_file in $WC_FILES; do
          if [[ -f "$wc_file" ]] && grep -q '\\documentclass' "$wc_file"; then
            echo "ðŸ”¢ Calculating word count for $wc_file..."
            WORDS=$(texcount -inc -total "$wc_file" | grep -E "Words in text|Total Words in text" | awk '{print $NF}')
            echo "Word count for $wc_file: $WORDS"
            sed -i "s/wordcount{[0-9]*}/wordcount{$WORDS}/" "$wc_file"
            git add "$wc_file"
          fi
        done

    - name: Commit and push changes
      if: steps.buildset.outputs.files != '' || steps.wordcount_check.outputs.files != ''
      shell: bash
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        
        if [[ "${{ steps.buildset.outputs.files }}" != "" ]]; then
          git add ${{ inputs.output-dir }}
        fi
        
        git commit -m "${{ inputs.commit-message }} ($(date))" || echo "No changes to commit"
        git push
